<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | I'm Durrell Chamorro]]></title>
  <link href="http://durrellchamorro.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://durrellchamorro.github.io/"/>
  <updated>2016-01-31T19:39:24-08:00</updated>
  <id>http://durrellchamorro.github.io/</id>
  <author>
    <name><![CDATA[Durrell Chamorro]]></name>
    <email><![CDATA[durrell.chamorro@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Using Procs to DRY up Ruby Code]]></title>
    <link href="http://durrellchamorro.github.io/blog/2016/01/30/use-procs-to-dry-up-code/"/>
    <updated>2016-01-30T22:58:51-08:00</updated>
    <id>http://durrellchamorro.github.io/blog/2016/01/30/use-procs-to-dry-up-code</id>
    <content type="html"><![CDATA[<p>Ruby code is full of blocks. Blocks are essentially chunks of code that allow you to defer
the precise way a method will work to the time of the method invocation. For example,
if you encounter a scenario where you&rsquo;re calling a method from multiple places,
with one little tweak in each case, it may be a good idea implement the
method in a generic way by yielding to a block. By defining one method instead of many similar
methods your code stays DRY. The problem is Ruby only lets you
yield to one block per method. In this post I&rsquo;ll explain how to send procs to methods so
you can tweak your generic methods in more than one way at a time.  Along the way I explain
how some of Ruby&rsquo;s syntactic sugar works, and I close with a real world example of how I implemented
all this in an app. <!--more--></p>

<p>Instead of:
<code>ruby
[1].map { |n| n.to_s }
</code>
you can use this syntactic sugar:
<code>ruby
[1].map(&amp;:to_s)
</code></p>

<p>This works because in the context of a method call, putting an ampersand in front of the
<a href="#LastArgument">*last argument</a>
tells Ruby to convert whatever is immediately to the right of the ampersand
to a proc if it isn&rsquo;t a proc already and then use that proc as the methodâ€™s block.
For example, these 5 examples all return the same thing:</p>

<p>1) The traditional way:
<code>ruby
[1].map { |n| n.to_s } # =&gt; ["1"]
</code></p>

<p>2) Below the ampersand calls <code>Symbol#to_proc</code> on <code>:to_s</code> and then makes sure that proc is used as the method&rsquo;s block.
Click <a href="#SymbolToProc">here</a> for an explanation of how <code>Symbol#to_proc</code> works.
<a name="LastArgument"></a>*Technically speaking, Ruby does not consider the ampersand followed by a proc (or in this case a symbol being
converted to a proc) to be an argument for the method. If it did, then this would cause a wrong number of arguments
(1 for 0) error since <code>Array#map</code> doesn&rsquo;t take any arguments.</p>

<pre><code class="ruby">[1].map(&amp;:to_s) # =&gt; ["1"]
</code></pre>

<p>3) Since <code>a_proc</code> is already a proc, the ampersand doesn&rsquo;t need to call <code>#to_proc</code> on it. Instead it will just make
sure the proc is used as the method&rsquo;s block:</p>

<pre><code class="ruby">a_proc = :to_s.to_proc
[1].map(&amp;a_proc) # =&gt; ["1"]
</code></pre>

<p>4) You can create a proc and assign it to a local variable that describes what the proc does:</p>

<pre><code class="ruby">call_to_s_on_the_object = Proc.new { |object| object.to_s }
[1].map(&amp;call_to_s_on_the_object) # =&gt; ["1"]
</code></pre>

<p>5) Instead of <code>Proc.new</code> you can just write this:
<code>ruby
a_shorter_way_to_create_a_proc = proc { |object| object.to_s }
[1].map(&amp;a_shorter_way_to_create_a_proc) # =&gt; ["1"]
</code></p>

<p>Procs do more than just give us syntactic sugar.
<a href="#RealWorldExample">They helped me combine two methods into one.</a>
If you have two methods that are the same, except for a block inside the methods and both methods are
already yielding to a block like below, you can&rsquo;t yield to two different blocks, but you can
pass in a proc to handle the difference. Here are three methods. The first two can be replaced by the third.
<a href="https://gist.github.com/durrellchamorro/220045206c525bd72f78">Here is code</a> you
can run in your terminal to see how all the examples in this post work firsthand.</p>

<pre><code class="ruby">def my_first_method(array)
  array.each { |string| p string + ' whatever' }
  array.each { |object| p yield object }
end

def my_second_method(array)
  array.each { |object| p object + 5 }
  array.each { |object| p yield object }
end

def you_only_need_one_method(array, some_proc)
  array.each(&amp;some_proc)
  array.each { |object| p yield object }
end
</code></pre>

<p><a name="SymbolToProc"></a></p>

<h3>The Symbol class defines <code>#to_proc</code> like so:</h3>

<pre><code class="ruby">class Symbol
  def to_proc
    Proc.new { |obj, *args| obj.send(self, *args) }
  end
end
</code></pre>

<p>Therefore, calling <code>#to_proc</code> on a symbol returns a proc.
<code>[1, 2].to_s</code> is the same as <code>[1, 2].send(:to_s)</code>.
Likewise, <code>[1, 2].delete_at(0)</code> is the same as <code>[1, 2].send(:delete_at, 0)</code>.
With this in mind, consider the following:</p>

<pre><code class="ruby">def foo!(array, index)
  yield array, index
end

my_array = [1, 2]

foo!(my_array, 0, &amp;:delete_at) # This is the same as: my_array.delete_at(0)

my_array # =&gt; [2]
</code></pre>

<p>The code below proves <code>delete_at_proc</code> and <code>delete_at_proc2</code> are equivalent:</p>

<pre><code class="ruby">delete_at_proc = Proc.new { |obj, index| obj.delete_at(index) }
my_array = [1, 2]

foo!(my_array, 0, &amp;delete_at_proc)

my_array # =&gt; [2]

delete_at_proc2 = :delete_at.to_proc
my_array = [1, 2]

foo!(my_array, 0, &amp;delete_at_proc2)

my_array # =&gt; [2]
</code></pre>

<h3><a name="RealWorldExample"></a> A Real World Example of all this in Action</h3>

<p>The <code>#sort</code> helper method below is written in a generic way so two things can be customized
at method invocation time.</p>

<h4>1. The collection can be any object that can be sent <code>#partition</code> and <code>#index</code>.</h4>

<h4>2. The block being yielded to can be customized.</h4>

<p><code>#sort</code> uses <code>#partition</code> to split a collection into two arrays: complete and incomplete. <code>#partition</code>
iterates through each element in the collection and decides
which array each element of the collection will go to depending
on whether <code>#partition</code>&rsquo;s' block evaluates to true. Next, <code>#sort</code>
yields the newly created arrays to the block in a view. Therefore,
I needed a different way to check the status of different kinds of collections
in order for <code>#partition</code>&rsquo;s block to return true or false for the different kinds collections.
Instead of defining a sorting method for each kind of collection that would use a unique block for <code>#partition</code>
made special to evaluate the status of that particular collection&rsquo;s elements, I created unique procs
for each kind of collection and used those procs for <code>#partition</code>&rsquo;s block. In this way
I was able to write one method that can sort different kinds of collections and then send the sorted collection
to a custom block.</p>

<pre><code class="ruby">def sort(collection, check_item_status)
  complete_collection, incomplete_collection = collection.partition(&amp;check_item_status)

  incomplete_collection.each { |item| yield item, collection.index(item) }
  complete_collection.each { |item| yield item, collection.index(item) }
end
</code></pre>

<p>In this view <code>#sort</code> yields to a custom block of erb code that displays the contents of
one kind of collection (todo items) in an unordered list:</p>

<pre><code class="erb">&lt;% check_todo_status = proc { |todo| todo[:status] == 'complete' } %&gt;
&lt;% sort(@list[:todos], check_todo_status) do |todo, index| %&gt;
  &lt;ul&gt;
    &lt;li class="&lt;%= todo[:status] %&gt;"&gt;
      &lt;form action="/lists/&lt;%= @list_id %&gt;/todos/&lt;%= index %&gt;" method="post" class="check"&gt;
        &lt;input type="hidden" name="status" value="&lt;%= opposite_status_of(todo[:status]) %&gt;" &gt;
        &lt;button type="submit"&gt;Complete&lt;/button&gt;
      &lt;/form&gt;
      &lt;h3&gt;&lt;%= todo[:name] %&gt;&lt;/h3&gt;
      &lt;form action="/lists/&lt;%= @list_id %&gt;/todos/&lt;%= index %&gt;/destroy"
        method="post" class="delete"&gt;
        &lt;button type="submit"&gt;Delete&lt;/button&gt;
      &lt;/form&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;% end %&gt;
</code></pre>

<p>In the view below <code>#sort</code> yields to a custom block of erb code that displays the contents of a
different kind of collection (a list of todo lists) in an unordered list.</p>

<p>```erb</p>

<ul id="lists">
  <% check_list_status = proc { |list| all_complete?(list) == 'complete' } %>
  <% sort(@lists, check_list_status) do |list, index| %>
    <li class="<%=all_complete?(list)%>">
      <h2><a href="lists/<%= index %>"><%= list[:name] %></a></h2>
      <%= display_progress(list) %>
    </li>
  <% end %>
</ul>


<p>```</p>
]]></content>
  </entry>
  
</feed>
